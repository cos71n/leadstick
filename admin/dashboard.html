<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeadStick Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #1f2937;
            line-height: 1.6;
        }

        .auth-check {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8fafc;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .auth-check .loading {
            text-align: center;
            color: #6b7280;
        }

        .header {
            background: white;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-bottom: 1px solid #e5e7eb;
            position: relative;
        }

        .header h1 {
            color: #1f2937;
            font-size: 24px;
            font-weight: 600;
        }

        .header p {
            color: #6b7280;
            margin-top: 4px;
        }

        .logout-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #dc2626;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .logout-btn:hover {
            background: #b91c1c;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            gap: 20px;
        }

        .search-box {
            flex: 1;
            max-width: 400px;
            position: relative;
        }

        .search-box input {
            width: 100%;
            padding: 12px 16px 12px 40px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            transition: border-color 0.2s;
        }

        .search-box input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-box::before {
            content: 'üîç';
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-danger {
            background: #dc2626;
            color: white;
        }

        .btn-danger:hover {
            background: #b91c1c;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 13px;
        }

        .clients-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .client-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e5e7eb;
            transition: all 0.2s;
        }

        .client-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .client-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .client-info h3 {
            color: #1f2937;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .client-info .site-id {
            color: #6b7280;
            font-size: 14px;
            font-family: monospace;
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .theme-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
            flex-shrink: 0;
        }

        .client-details {
            margin-bottom: 16px;
        }

        .client-detail {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .client-detail .icon {
            width: 16px;
            text-align: center;
        }

        .questions-count {
            background: #f0f9ff;
            color: #0369a1;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .client-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid #f3f4f6;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }

        .error {
            background: #fee2e2;
            color: #991b1b;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #fca5a5;
        }

        .success {
            background: #d1fae5;
            color: #065f46;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #6ee7b7;
        }

        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: #6b7280;
        }

        .empty-state h3 {
            color: #374151;
            margin-bottom: 8px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 900px;
            width: 95%;
            max-height: 95vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .modal-header h2 {
            color: #1f2937;
            font-size: 20px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6b7280;
            padding: 4px;
        }

        .modal-tabs {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 24px;
        }

        .modal-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .modal-tab.active {
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #374151;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            background: white;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .validation-error {
            color: #dc2626;
            font-size: 12px;
            margin-top: 4px;
            display: none;
        }

        .form-group.error input,
        .form-group.error textarea,
        .form-group.error select {
            border-color: #dc2626;
            background: #fef2f2;
        }

        .form-group.error input:focus,
        .form-group.error textarea:focus,
        .form-group.error select:focus {
            border-color: #dc2626;
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1);
        }

        .search-box.error input {
            border-color: #dc2626;
            background: #fef2f2;
        }

        .form-group .help-text {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .color-input {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .color-input input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .color-input input[type="text"] {
            flex: 1;
        }

        .questions-builder {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f8fafc;
            padding: 20px;
        }

        .questions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .questions-header h3 {
            color: #1f2937;
            font-size: 16px;
            font-weight: 600;
        }

        .add-question-dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background: white;
            min-width: 200px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            z-index: 1;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            padding: 12px 16px;
            text-decoration: none;
            color: #374151;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
        }

        .dropdown-item:hover {
            background: #f3f4f6;
        }

        .question-list {
            min-height: 100px;
        }

        .question-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: move;
            transition: all 0.2s;
        }

        .question-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .question-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .question-info h4 {
            color: #1f2937;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .question-type {
            color: #6b7280;
            font-size: 12px;
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .question-actions {
            display: flex;
            gap: 8px;
        }

        .question-actions button {
            padding: 6px 12px;
            font-size: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #f3f4f6;
            color: #6b7280;
        }

        .question-actions button:hover {
            background: #e5e7eb;
        }

        .question-preview {
            color: #6b7280;
            font-size: 13px;
            line-height: 1.4;
        }

        .options-list {
            margin-top: 8px;
            padding-left: 16px;
        }

        .options-list li {
            color: #9ca3af;
            font-size: 12px;
        }

        .flow-signpost {
            background: #2563eb;
            color: white;
            border: none;
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 8px;
            cursor: move;
            transition: all 0.2s;
        }

        .flow-signpost:hover {
            background: #1d4ed8;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .flow-signpost-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .flow-signpost-title {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }

        .flow-signpost-subtitle {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 4px;
        }

        .flow-signpost-actions {
            display: flex;
            gap: 8px;
        }

        .flow-signpost-actions button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .flow-signpost-actions button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .question-item.nested {
            margin-left: 30px;
            border-left: 3px solid #2563eb;
            padding-left: 15px;
            margin-top: 8px;
            position: relative;
        }

        .question-item.nested::before {
            content: '';
            position: absolute;
            left: -3px;
            top: -8px;
            height: 8px;
            width: 20px;
            border-left: 3px solid #2563eb;
            border-bottom: 3px solid #2563eb;
            border-bottom-left-radius: 8px;
        }

        .question-type-tag {
            background: #eff6ff;
            color: #2563eb;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .required-badge {
            background: #fef2f2;
            color: #dc2626;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 4px;
        }

        .signpost-builder {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f8fafc;
            padding: 20px;
        }

        .signpost-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .signpost-header h3 {
            color: #1f2937;
            font-size: 16px;
            font-weight: 600;
        }

        .signpost-info {
            margin-bottom: 12px;
        }

        .signpost-info small {
            color: #6b7280;
            font-size: 12px;
        }

        .signpost-list {
            min-height: 100px;
        }

        .signpost-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: move;
            transition: all 0.2s;
        }

        .signpost-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .signpost-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .signpost-header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .signpost-info-content h4 {
            color: #1f2937;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .signpost-info-content p {
            color: #6b7280;
            font-size: 12px;
            margin: 0;
        }

        .signpost-actions {
            display: flex;
            gap: 8px;
        }

        .signpost-actions button {
            padding: 6px 12px;
            font-size: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #f3f4f6;
            color: #6b7280;
        }

        .signpost-actions button:hover {
            background: #e5e7eb;
        }

        .signpost-questions {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }

        .signpost-questions h5 {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 8px;
        }

        .signpost-question-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .signpost-question-tag {
            background: #eff6ff;
            color: #2563eb;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid #dbeafe;
        }

        .question-editor-modal .modal-content {
            max-width: 600px;
        }

        .option-builder {
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px;
            margin-top: 8px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .option-item input {
            flex: 1;
            margin: 0;
        }

        .option-item button {
            padding: 4px 8px;
            background: #fee2e2;
            color: #dc2626;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #f3f4f6;
        }

        .drag-handle {
            color: #9ca3af;
            cursor: move;
            margin-right: 8px;
        }

        @media (max-width: 768px) {
            .toolbar {
                flex-direction: column;
                align-items: stretch;
            }

            .search-box {
                max-width: none;
            }

            .clients-grid {
                grid-template-columns: 1fr;
            }

            .client-actions {
                flex-direction: column;
            }

            .modal-content {
                width: 95%;
                padding: 20px;
                margin: 10px;
            }

            .modal-tabs {
                overflow-x: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Check Screen -->
    <div id="authCheck" class="auth-check">
        <div class="loading">
            <div>üîê Verifying access...</div>
        </div>
    </div>

    <!-- Main Dashboard (Hidden until authenticated) -->
    <div id="mainContent" style="display: none;">
        <div class="header">
            <h1>üöÄ LeadStick Dashboard</h1>
            <p>Manage your client widget configurations</p>
            <button onclick="logout()" class="logout-btn">
                Logout
            </button>
        </div>

        <div class="container">
            <div class="toolbar">
                <div class="search-box" id="searchBox">
                    <input 
                        type="text" 
                        id="searchInput" 
                        placeholder="Search clients..." 
                        maxlength="100"
                        oninput="validateSearchInput()"
                        onkeyup="filterClients()"
                    >
                    <div id="searchError" class="validation-error"></div>
                </div>
                <button class="btn btn-primary" onclick="openNewClientModal()">
                    ‚ûï Add New Client
                </button>
            </div>

            <div id="statusMessage"></div>
            
            <div id="loadingState" class="loading">
                <div>Loading clients...</div>
            </div>

            <div id="clientsContainer" class="clients-grid" style="display: none;">
                <!-- Clients will be loaded here -->
            </div>

            <div id="emptyState" class="empty-state" style="display: none;">
                <h3>No clients yet</h3>
                <p>Get started by adding your first client configuration</p>
                <button class="btn btn-primary" onclick="openNewClientModal()" style="margin-top: 20px;">
                    ‚ûï Add Your First Client
                </button>
            </div>
        </div>

        <!-- Edit Client Modal -->
        <div id="editModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Edit Client Configuration</h2>
                    <button class="close-btn" onclick="closeEditModal()">&times;</button>
                </div>

                <form id="editClientForm" onsubmit="saveClientChanges(event)">
                    <!-- Site ID is now auto-generated and hidden -->
                    <input type="hidden" id="editSiteId" name="siteId">

                    <div class="form-group">
                        <label for="editBusinessName">Business Name *</label>
                        <input 
                            type="text" 
                            id="editBusinessName" 
                            name="businessName" 
                            required
                            maxlength="100"
                            oninput="validateEditInput('editBusinessName', this.value, 'businessName')"
                        >
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="editEmail">Email Address *</label>
                        <input 
                            type="text" 
                            id="editEmail" 
                            name="email" 
                            required
                            maxlength="300"
                            placeholder="leads@example.com or multiple@example.com, backup@example.com"
                            oninput="validateEditInput('editEmail', this.value, 'email')"
                        >
                        <div class="help-text">Enter one email address or multiple addresses separated by commas</div>
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="editAgentName">Agent Name</label>
                        <input 
                            type="text" 
                            id="editAgentName" 
                            name="agentName" 
                            maxlength="50"
                            oninput="validateEditInput('editAgentName', this.value, 'agentName')"
                        >
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="editPhone">Phone Number</label>
                        <input 
                            type="tel" 
                            id="editPhone" 
                            name="phone" 
                            maxlength="20"
                            oninput="validateEditInput('editPhone', this.value, 'phone')"
                        >
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="editTheme">Theme Color</label>
                        <div class="color-input">
                            <input 
                                type="color" 
                                id="editThemeColor" 
                                value="#3b82f6"
                                onchange="syncEditColorInputs()"
                            >
                            <input 
                                type="text" 
                                id="editThemeText" 
                                value="#3b82f6"
                                maxlength="7"
                                placeholder="#f6a560"
                                oninput="syncEditColorInputs()"
                            >
                        </div>
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label>Widget Type</label>
                        <div style="display: flex; gap: 12px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input 
                                    type="radio" 
                                    name="widgetType" 
                                    value="bubble" 
                                    id="editBubble"
                                    checked
                                >
                                <span>Bubble Widget</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input 
                                    type="radio" 
                                    name="widgetType" 
                                    value="bar" 
                                    id="editFloatingBar"
                                >
                                <span>Floating Bar</span>
                            </label>
                        </div>
                    </div>

                    <div class="form-group" id="barTextGroup" style="display: none;">
                        <label for="barText">Floating Bar Text</label>
                        <input 
                            type="text" 
                            id="barText" 
                            name="barText" 
                            maxlength="30"
                            placeholder="Get A Quick Quote"
                            oninput="validateEditInput('barText', this.value, 'barText')"
                        >
                        <div class="help-text">Text displayed on the floating bar (max 30 characters)</div>
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="welcomeMessage">Welcome Message</label>
                        <textarea 
                            id="welcomeMessage" 
                            name="welcomeMessage" 
                            maxlength="500"
                            rows="3"
                        >Hi, [Agent Name] here. Let me know a little about your project. Your message comes straight to my phone and I'll send your quote ASAP</textarea>
                        <div class="help-text">The first message users see when they open the chat widget. Use [Agent Name] to automatically insert the agent's name.</div>
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="completionMessage">Completion Message</label>
                        <textarea 
                            id="completionMessage" 
                            name="completionMessage" 
                            maxlength="500"
                            rows="3"
                        >Perfect! I've got your details. I'll get back to you ASAP.</textarea>
                        <div class="help-text">Message shown after the user completes the form. Use [Agent Name] to automatically insert the agent's name.</div>
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="phoneCtaText">Phone Call Button Text</label>
                        <input 
                            type="text" 
                            id="phoneCtaText" 
                            name="phoneCtaText" 
                            maxlength="100"
                            value="Or call me directly for immediate assistance!"
                            oninput="validateEditInput('phoneCtaText', this.value, 'message')"
                        >
                        <div class="help-text">Text shown above the phone call button</div>
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label>
                            <input 
                                type="checkbox" 
                                id="showPhoneCta" 
                                name="showPhoneCta" 
                                checked
                            >
                            Show phone call button after form completion
                        </label>
                    </div>

                    <div class="form-group">
                        <label>Questions & Flow</label>
                        <div class="questions-builder">
                            <div class="questions-header">
                                <h3>Question Flow</h3>
                                <div class="add-question-dropdown">
                                    <button type="button" class="btn btn-primary btn-small" onclick="toggleQuestionDropdown()">
                                        ‚ûï Add Item
                                    </button>
                                    <div class="dropdown-content" id="questionDropdown">
                                        <div style="border-bottom: 1px solid #e5e7eb; padding-bottom: 4px; margin-bottom: 4px;">
                                            <button type="button" class="dropdown-item" onclick="addSignpost()" style="font-weight: 600;">üéØ Signpost</button>
                                        </div>
                                        <button type="button" class="dropdown-item" onclick="addQuestion('text')">üìù Text Input</button>
                                        <button type="button" class="dropdown-item" onclick="addQuestion('select')">üìã Single Choice</button>
                                        <button type="button" class="dropdown-item" onclick="addQuestion('multiselect')">‚òëÔ∏è Multiple Choice</button>
                                        <button type="button" class="dropdown-item" onclick="addQuestion('firstName')">üë§ First Name</button>
                                        <button type="button" class="dropdown-item" onclick="addQuestion('lastName')">üë§ Last Name</button>
                                        <button type="button" class="dropdown-item" onclick="addQuestion('email')">üìß Email Address</button>
                                        <button type="button" class="dropdown-item" onclick="addQuestion('phone')">üìû Phone Number</button>
                                    </div>
                                </div>
                            </div>
                            <div class="question-list" id="questionList">
                                <!-- Questions will be rendered here -->
                            </div>
                        </div>
                    </div>

                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeEditModal()">
                            Cancel
                        </button>
                        <button type="submit" class="btn btn-primary">
                            Save Changes
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Question Editor Modal -->
        <div id="questionEditorModal" class="modal question-editor-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="questionEditorTitle">Add Question</h2>
                    <button class="close-btn" onclick="closeQuestionEditor()">&times;</button>
                </div>

                <form id="questionEditorForm" onsubmit="saveQuestion(event)">
                    <div class="form-group">
                        <label for="questionText">Question Text *</label>
                        <input 
                            type="text" 
                            id="questionText" 
                            name="questionText" 
                            required
                            maxlength="200"
                            placeholder="What question do you want to ask?"
                        >
                        <div class="validation-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="questionType">Question Type *</label>
                        <select id="questionType" name="questionType" onchange="updateQuestionTypeOptions()" required>
                            <option value="text">üìù Text Input</option>
                            <option value="select">üìã Single Choice</option>
                            <option value="multiselect">‚òëÔ∏è Multiple Choice</option>
                            <option value="firstName">üë§ First Name</option>
                            <option value="lastName">üë§ Last Name</option>
                            <option value="email">üìß Email Address</option>
                            <option value="phone">üìû Phone Number</option>
                        </select>
                        <div class="validation-error"></div>
                    </div>


                    <div class="form-group" id="placeholderGroup">
                        <label for="questionPlaceholder">Placeholder Text</label>
                        <input 
                            type="text" 
                            id="questionPlaceholder" 
                            name="questionPlaceholder" 
                            maxlength="100"
                            placeholder="Helper text for the user"
                        >
                        <div class="help-text">Optional helper text shown to users</div>
                    </div>

                    <div class="form-group" id="optionsGroup" style="display: none;">
                        <label>Answer Options</label>
                        <div class="option-builder">
                            <div id="optionsList">
                                <!-- Options will be added here -->
                            </div>
                            <button type="button" class="btn btn-secondary btn-small" onclick="addOption()">
                                ‚ûï Add Option
                            </button>
                        </div>
                    </div>

                    <div class="form-group" id="validationGroup">
                        <label>Validation Rules</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="questionRequired" name="questionRequired" checked>
                                <span>Required field</span>
                            </label>
                        </div>
                        <div id="minLengthGroup" style="display: none;">
                            <label for="minLength" style="margin-bottom: 4px; font-size: 14px;">Minimum characters:</label>
                            <input type="number" id="minLength" name="minLength" min="1" max="500" value="1" style="width: 100px;">
                        </div>
                        <div id="minSelectionGroup" style="display: none;">
                            <label for="minSelection" style="margin-bottom: 4px; font-size: 14px;">Minimum selections:</label>
                            <input type="number" id="minSelection" name="minSelection" min="1" max="10" value="1" style="width: 100px;">
                        </div>
                    </div>

                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeQuestionEditor()">
                            Cancel
                        </button>
                        <button type="submit" class="btn btn-primary">
                            Save Question
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Signpost Editor Modal -->
    <div id="signpostEditorModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="signpostEditorTitle">Add Signpost</h2>
                <button class="close-btn" onclick="closeSignpostEditor()">&times;</button>
            </div>

            <form id="signpostEditorForm" onsubmit="saveSignpost(event)">
                <div class="form-group">
                    <label for="signpostHeading">Signpost Heading *</label>
                    <input 
                        type="text" 
                        id="signpostHeading" 
                        name="signpostHeading" 
                        required
                        maxlength="50"
                        placeholder="e.g., Location, Project Details, Contact"
                    >
                    <div class="help-text">This appears as the main step title</div>
                </div>

                <div class="form-group">
                    <label for="signpostSubheading">Subheading *</label>
                    <input 
                        type="text" 
                        id="signpostSubheading" 
                        name="signpostSubheading" 
                        required
                        maxlength="100"
                        placeholder="e.g., Where are you?, Tell us about it, Your details"
                    >
                    <div class="help-text">Brief description shown below the heading</div>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeSignpostEditor()">
                        Cancel
                    </button>
                    <button type="submit" class="btn btn-primary">
                        Save Signpost
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script id="main-script">
        console.log('[Dashboard] Script loaded, starting initialization...');
        
        // CSP-safe script initialization
        (async function initializeApp() {
            console.log('[Dashboard] initializeApp IIFE started');
            try {
                // Fetch nonce from API for CSP compliance
                console.log('[Dashboard] Fetching nonce...');
                const nonceResponse = await fetch('https://leadstick-api.attribution.workers.dev/admin/nonce');
                const nonceData = await nonceResponse.json();
                console.log('[Dashboard] Nonce received:', !!nonceData.nonce);
                
                // Set nonce for any dynamically created scripts
                window.CSP_NONCE = nonceData.nonce;
                
                // Initialize app constants
                window.API_BASE = 'https://leadstick-api.attribution.workers.dev';
                window.sessionToken = null;
                window.csrfToken = null;
                window.clients = [];
                window.editingClient = null;
                
                console.log('[Dashboard] App constants initialized, calling initializeAppComponents...');
                // Continue with app initialization
                initializeAppComponents();
            } catch (error) {
                console.error('Failed to initialize app:', error);
                // Fallback initialization without nonce
                console.log('[Dashboard] Using fallback initialization...');
                window.API_BASE = 'https://leadstick-api.attribution.workers.dev';
                window.sessionToken = null;
                window.csrfToken = null;
                window.clients = [];
                window.editingClient = null;
                initializeAppComponents();
            }
        })();

        function initializeAppComponents() {
            console.log('[Init] initializeAppComponents called');
            
            // Use global variables for consistency
            const API_BASE = window.API_BASE;
            let sessionToken = window.sessionToken;
            let csrfToken = window.csrfToken;
            let clients = window.clients;
            let editingClient = window.editingClient;
            
            // Make these accessible to all functions
            window.getSessionToken = () => sessionToken || sessionStorage.getItem('leadstick_admin_token');
            window.getCsrfToken = () => csrfToken || sessionStorage.getItem('leadstick_csrf_token');
            window.getClients = () => window.clients || [];
            
            console.log('[Init] Initial values:', {
                API_BASE: API_BASE,
                hasSessionToken: !!sessionToken,
                hasCsrfToken: !!csrfToken
            });
            
            let currentFlow = [];
            let editingItemIndex = -1;
            
            // Flow management global state
            window.currentFlow = currentFlow;
            window.editingItemIndex = editingItemIndex;

            // Authentication check function
            async function checkAuthentication() {
                console.log('[Dashboard] Starting authentication check...');
                const authCheckDiv = document.getElementById('authCheck');
                const mainContentDiv = document.getElementById('mainContent');
                
                try {
                    // Get stored tokens
                    sessionToken = sessionStorage.getItem('leadstick_admin_token');
                    csrfToken = sessionStorage.getItem('leadstick_csrf_token');
                    
                    console.log('[Dashboard] Token check:', {
                        hasSessionToken: !!sessionToken,
                        sessionTokenLength: sessionToken ? sessionToken.length : 0,
                        hasCsrfToken: !!csrfToken,
                        csrfTokenLength: csrfToken ? csrfToken.length : 0
                    });
                    
                    if (!sessionToken || !csrfToken) {
                        console.log('[Dashboard] Missing tokens, redirecting to login');
                        throw new Error('No authentication tokens found');
                    }
                    
                    console.log('[Dashboard] Making authentication request to API...');
                    console.log('[Dashboard] API URL:', `${API_BASE}/admin/clients`);
                    
                    // Verify tokens with server by trying to load clients
                    const response = await authenticatedFetch(`${API_BASE}/admin/clients`);
                    
                    console.log('[Dashboard] API Response:', {
                        status: response.status,
                        statusText: response.statusText,
                        ok: response.ok,
                        headers: Object.fromEntries(response.headers.entries())
                    });
                    
                    if (!response.ok) {
                        console.log('[Dashboard] Response not OK, checking status...');
                        const errorBody = await response.text();
                        console.log('[Dashboard] Error response body:', errorBody);
                        throw new Error('Invalid or expired session');
                    }
                    
                    console.log('[Dashboard] Authentication successful, parsing response...');
                    const data = await response.json();
                    console.log('[Dashboard] Response data:', data);
                    
                    // Authentication successful
                    console.log('[Dashboard] Hiding auth check, showing main content');
                    authCheckDiv.style.display = 'none';
                    mainContentDiv.style.display = 'block';
                    
                    // Load dashboard data
                    console.log('[Dashboard] Loading dashboard components...');
                    loadClients();
                    setupColorInputSync();
                    setupDragAndDrop();
                    
                } catch (error) {
                    console.error('[Dashboard] Authentication error:', error);
                    console.error('[Dashboard] Error stack:', error.stack);
                    console.warn('Authentication failed:', error.message);
                    // Redirect to login page
                    console.log('[Dashboard] Redirecting to login page...');
                    window.location.href = './index.html';
                }
            }
            
            // Check if DOM is already loaded, otherwise wait for it
            if (document.readyState === 'loading') {
                console.log('[Dashboard] DOM still loading, adding event listener...');
                document.addEventListener('DOMContentLoaded', checkAuthentication);
            } else {
                console.log('[Dashboard] DOM already loaded, running authentication check immediately...');
                checkAuthentication();
            }

        // Create authenticated fetch function
        function authenticatedFetch(url, options = {}) {
            console.log('[authenticatedFetch] Called with:', { url, method: options.method || 'GET' });
            
            const currentToken = window.getSessionToken();
            if (!currentToken) {
                console.error('[authenticatedFetch] No session token available!');
                throw new Error('Not authenticated');
            }
            
            const authHeaders = {
                'Authorization': `Bearer ${currentToken}`,
                'Content-Type': 'application/json',
                ...options.headers
            };
            
            // Add CSRF token for state-changing operations
            const currentCsrfToken = window.getCsrfToken();
            if (options.method && ['POST', 'PUT', 'DELETE'].includes(options.method.toUpperCase()) && currentCsrfToken) {
                console.log('[authenticatedFetch] Adding CSRF token for state-changing operation');
                authHeaders['X-CSRF-Token'] = currentCsrfToken;
            }
            
            console.log('[authenticatedFetch] Request headers:', authHeaders);
            
            return fetch(url, {
                ...options,
                headers: authHeaders
            });
        }

        // Load all clients
        async function loadClients() {
            console.log('[loadClients] Starting to load clients...');
            try {
                showLoading(true);
                console.log('[loadClients] Making request to:', `${API_BASE}/admin/clients`);
                const response = await authenticatedFetch(`${API_BASE}/admin/clients`);
                
                console.log('[loadClients] Response received:', {
                    status: response.status,
                    ok: response.ok
                });
                
                const data = await response.json();
                console.log('[loadClients] Response data:', data);
                console.log('[loadClients] First client raw data:', data.clients[0]);

                if (!response.ok) {
                    console.log('[loadClients] Response not OK, status:', response.status);
                    if (response.status === 401) {
                        console.log('[loadClients] 401 - Session expired, redirecting to login');
                        // Session expired, redirect to login
                        window.location.href = './index.html';
                        return;
                    }
                    throw new Error(data.error || 'Failed to load clients');
                }

                clients = data.clients || [];
                window.clients = clients; // Store globally
                console.log('[loadClients] Loaded clients count:', clients.length);
                console.log('[loadClients] Client site IDs:', clients.map(c => c.siteId));
                renderClients();
            } catch (error) {
                console.error('[loadClients] Error:', error);
                showError('Failed to load clients: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Render clients grid
        function renderClients() {
            const container = document.getElementById('clientsContainer');
            const emptyState = document.getElementById('emptyState');

            if (clients.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            container.style.display = 'grid';
            emptyState.style.display = 'none';

            // Clear container safely
            container.textContent = '';
            
            // Create client cards using safe DOM manipulation
            clients.forEach(client => {
                const clientCard = document.createElement('div');
                clientCard.className = 'client-card';
                clientCard.setAttribute('data-site-id', client.siteId);
                
                // Client header
                const header = document.createElement('div');
                header.className = 'client-header';
                
                const clientInfo = document.createElement('div');
                clientInfo.className = 'client-info';
                
                const title = document.createElement('h3');
                title.textContent = client.businessName || 'Unnamed Business';
                clientInfo.appendChild(title);
                
                const siteIdDiv = document.createElement('div');
                siteIdDiv.className = 'site-id';
                siteIdDiv.textContent = client.siteId;
                clientInfo.appendChild(siteIdDiv);
                
                const themePreview = document.createElement('div');
                themePreview.className = 'theme-preview';
                themePreview.style.backgroundColor = client.theme;
                
                header.appendChild(clientInfo);
                header.appendChild(themePreview);
                
                // Client details
                const details = document.createElement('div');
                details.className = 'client-details';
                
                // Agent detail
                const agentDetail = document.createElement('div');
                agentDetail.className = 'client-detail';
                const agentIcon = document.createElement('span');
                agentIcon.className = 'icon';
                agentIcon.textContent = 'üë§';
                const agentName = document.createElement('span');
                agentName.textContent = client.agentName || 'No agent set';
                agentDetail.appendChild(agentIcon);
                agentDetail.appendChild(agentName);
                
                // Email detail
                const emailDetail = document.createElement('div');
                emailDetail.className = 'client-detail';
                const emailIcon = document.createElement('span');
                emailIcon.className = 'icon';
                emailIcon.textContent = '‚úâÔ∏è';
                const emailSpan = document.createElement('span');
                emailSpan.textContent = client.email || 'No email set';
                emailDetail.appendChild(emailIcon);
                emailDetail.appendChild(emailSpan);
                
                // Questions detail
                const questionsDetail = document.createElement('div');
                questionsDetail.className = 'client-detail';
                const questionsIcon = document.createElement('span');
                questionsIcon.className = 'icon';
                questionsIcon.textContent = '‚ùì';
                const questionsSpan = document.createElement('span');
                questionsSpan.className = 'questions-count';
                questionsSpan.textContent = 'Questions configured';
                questionsDetail.appendChild(questionsIcon);
                questionsDetail.appendChild(questionsSpan);
                
                details.appendChild(agentDetail);
                details.appendChild(emailDetail);
                details.appendChild(questionsDetail);
                
                // Client actions
                const actions = document.createElement('div');
                actions.className = 'client-actions';
                
                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-secondary btn-small';
                editBtn.textContent = '‚úèÔ∏è Edit';
                editBtn.onclick = () => {
                    console.log('[Edit Button] Clicked for client:', client.siteId);
                    try {
                        editClient(client.siteId);
                    } catch (error) {
                        console.error('[Edit Button] Error:', error);
                        alert('Error opening edit modal: ' + error.message);
                    }
                };
                
                const copyCodeBtn = document.createElement('button');
                copyCodeBtn.className = 'btn btn-primary btn-small';
                copyCodeBtn.textContent = 'üìã Copy Code';
                copyCodeBtn.onclick = () => copyInstallationCode(client.siteId);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-danger btn-small';
                deleteBtn.textContent = 'üóëÔ∏è Delete';
                deleteBtn.onclick = () => deleteClient(client.siteId);
                
                actions.appendChild(editBtn);
                actions.appendChild(copyCodeBtn);
                actions.appendChild(deleteBtn);
                
                // Assemble the card
                clientCard.appendChild(header);
                clientCard.appendChild(details);
                clientCard.appendChild(actions);
                
                container.appendChild(clientCard);
            });
        }

        // Input validation functions
        function validateSearchInput() {
            const searchInput = document.getElementById('searchInput');
            const searchBox = document.getElementById('searchBox');
            const searchError = document.getElementById('searchError');
            const searchTerm = searchInput.value;
            
            // Clear previous validation state
            searchBox.classList.remove('error');
            searchError.style.display = 'none';
            searchError.textContent = '';
            
            // Skip validation for empty input
            if (searchTerm.length === 0) {
                return true;
            }
            
            const errors = [];
            
            // Length validation
            if (searchTerm.length > 100) {
                errors.push('Search term is too long (max 100 characters)');
            }
            
            // Security validation - prevent XSS and injection attempts
            const dangerousChars = /<|>|'|"|;|--|\/\*|\*\/|script|javascript:|data:|vbscript:|onload|onerror/i;
            if (dangerousChars.test(searchTerm)) {
                errors.push('Search contains invalid characters');
            }
            
            // Prevent potential SQL injection patterns
            const sqlPatterns = /(\bselect\b|\binsert\b|\bupdate\b|\bdelete\b|\bdrop\b|\bunion\b|\bexec\b)/i;
            if (sqlPatterns.test(searchTerm)) {
                errors.push('Invalid search pattern');
            }
            
            if (errors.length > 0) {
                searchBox.classList.add('error');
                searchError.textContent = errors[0];
                searchError.style.display = 'block';
                return false;
            }
            
            return true;
        }
        
        function sanitizeInput(input) {
            if (typeof input !== 'string') return '';
            return input.trim().replace(/[<>'"&]/g, '');
        }
        
        function validateClientInput(inputId, value, type) {
            const errors = [];
            
            switch (type) {
                case 'siteId':
                    // Site ID is auto-generated, no validation needed
                    break;
                    
                case 'businessName':
                    if (!value) errors.push('Business name is required');
                    else if (value.length < 2) errors.push('Business name must be at least 2 characters');
                    else if (value.length > 100) errors.push('Business name must be less than 100 characters');
                    break;
                    
                case 'email':
                    if (!value) errors.push('Email is required');
                    else {
                        // Support multiple email addresses separated by commas
                        const emails = value.split(',').map(email => email.trim());
                        for (const email of emails) {
                            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                                errors.push(`Please enter a valid email address: ${email}`);
                            }
                        }
                        if (value.length > 300) errors.push('Email field must be less than 300 characters');
                    }
                    break;
                    
                case 'agentName':
                    if (value && value.length > 50) errors.push('Agent name must be less than 50 characters');
                    break;
                    
                case 'phone':
                    if (value && !/^[\d\s\-\+\(\)\.]+$/.test(value)) errors.push('Please enter a valid phone number');
                    else if (value && value.length > 20) errors.push('Phone number must be less than 20 characters');
                    break;
                    
                case 'message':
                    if (value && value.length > 500) errors.push('Message must be less than 500 characters');
                    break;
                    
                case 'barText':
                    if (value && value.length > 30) errors.push('Bar text must be less than 30 characters');
                    break;
                    
                case 'themeColor':
                    if (value && !/^#[0-9A-Fa-f]{6}$/.test(value)) errors.push('Theme color must be a valid hex color (e.g., #f6a560)');
                    break;
            }
            
            // Common security validation for all inputs
            const dangerousChars = /<|>|script|javascript:|data:|vbscript:|onload|onerror/i;
            if (dangerousChars.test(value)) {
                errors.push('Input contains invalid characters');
            }
            
            return errors;
        }
        
        function showInputError(inputId, message) {
            const input = document.getElementById(inputId);
            const group = input.closest('.form-group');
            let errorDiv = group.querySelector('.validation-error');
            
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.className = 'validation-error';
                group.appendChild(errorDiv);
            }
            
            group.classList.add('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        function clearInputError(inputId) {
            const input = document.getElementById(inputId);
            const group = input.closest('.form-group');
            const errorDiv = group.querySelector('.validation-error');
            
            group.classList.remove('error');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        // Enhanced search functionality with validation
        function filterClients() {
            // Validate search input first
            if (!validateSearchInput()) {
                return;
            }
            
            const searchTerm = sanitizeInput(document.getElementById('searchInput').value.toLowerCase());
            const clientCards = document.querySelectorAll('.client-card');

            clientCards.forEach(card => {
                const siteId = card.dataset.siteId.toLowerCase();
                const businessName = card.querySelector('h3').textContent.toLowerCase();
                const email = card.querySelector('.client-detail:nth-child(2) span:last-child').textContent.toLowerCase();

                if (siteId.includes(searchTerm) || businessName.includes(searchTerm) || email.includes(searchTerm)) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        }

        function openNewClientModal() {
            // Clear the form
            document.getElementById('editSiteId').value = ''; // Will be auto-generated
            document.getElementById('editBusinessName').value = '';
            document.getElementById('editEmail').value = '';
            document.getElementById('editAgentName').value = '';
            document.getElementById('editPhone').value = '';
            
            // Reset theme color
            document.getElementById('editThemeColor').value = '#3b82f6';
            document.getElementById('editThemeText').value = '#3b82f6';
            
            // Reset widget type
            document.getElementById('editBubble').checked = true;
            
            // Clear bar text and hide field
            document.getElementById('barText').value = '';
            document.getElementById('barTextGroup').style.display = 'none';
            
            // Keep default welcome message text (don't clear it)
            
            // Clear flow
            loadFlow([]);
            
            // Clear any previous validation errors
            document.querySelectorAll('#editModal .form-group').forEach(group => {
                group.classList.remove('error');
                const errorDiv = group.querySelector('.validation-error');
                if (errorDiv) errorDiv.style.display = 'none';
            });
            
            // Update modal title and form for create mode
            document.querySelector('#editModal .modal-header h2').textContent = 'Add New Client';
            document.querySelector('#editModal form').setAttribute('data-mode', 'create');
            document.querySelector('#editModal button[type="submit"]').textContent = 'Create Client';
            
            // Site ID is auto-generated, no help text needed
            
            // Clear editing client reference
            window.editingClient = null;
            
            // Show the modal
            document.getElementById('editModal').classList.add('active');
        }

        async function editClient(siteId) {
            const currentClients = window.getClients();
            const client = currentClients.find(c => c.siteId === siteId);
            if (!client) {
                showError('Client not found');
                return;
            }
            
            // Store the client being edited
            window.editingClient = client;
            
            // Debug: Log the client data
            console.log('[editClient] Client data:', client);
            console.log('[editClient] Available properties:', Object.keys(client));
            
            // Populate the form with client data
            document.getElementById('editSiteId').value = client.siteId || '';
            document.getElementById('editBusinessName').value = client.businessName || '';
            document.getElementById('editEmail').value = client.email || '';
            document.getElementById('editAgentName').value = client.agentName || '';
            document.getElementById('editPhone').value = client.phone || '';
            
            // Set theme color
            const themeColor = client.theme || '#3b82f6';
            document.getElementById('editThemeColor').value = themeColor;
            document.getElementById('editThemeText').value = themeColor;
            
            // Set widget type
            const widgetType = client.desktopStyle || 'bubble';
            if (widgetType === 'bar') {
                document.getElementById('editFloatingBar').checked = true;
                document.getElementById('barTextGroup').style.display = 'block';
            } else {
                document.getElementById('editBubble').checked = true;
                document.getElementById('barTextGroup').style.display = 'none';
            }
            
            // Set bar text
            document.getElementById('barText').value = client.barText || 'Get A Quick Quote';
            
            // Set welcome message
            const welcomeMessage = client.messages?.welcome || '';
            document.getElementById('welcomeMessage').value = welcomeMessage;
            
            // Set completion message
            const completionMessage = client.messages?.complete || '';
            document.getElementById('completionMessage').value = completionMessage;
            
            // Set phone CTA text
            const phoneCtaText = client.messages?.phoneButton || '';
            document.getElementById('phoneCtaText').value = phoneCtaText;
            
            // Set phone CTA toggle
            const showPhoneCta = client.showPhoneCta !== false; // Default to true
            document.getElementById('showPhoneCta').checked = showPhoneCta;
            
            // Load flow (unified structure of signposts and questions)
            if (client.flow && Array.isArray(client.flow)) {
                console.log('[editClient] Loading flow:', client.flow);
                loadFlow(client.flow);
            } else {
                console.log('[editClient] Converting legacy format');
                // Legacy support: convert old format to flow
                const legacyFlow = [];
                
                // Add signposts first if they exist
                if (client.signposts && Array.isArray(client.signposts)) {
                    client.signposts.forEach(signpost => {
                        legacyFlow.push({
                            ...signpost,
                            type: 'signpost'
                        });
                    });
                }
                
                // Add questions
                if (client.questions && Array.isArray(client.questions)) {
                    client.questions.forEach(question => {
                        legacyFlow.push({
                            ...question,
                            type: 'question',
                            questionType: question.type || 'text'
                        });
                    });
                }
                
                console.log('[editClient] Legacy flow:', legacyFlow);
                console.log('[editClient] Legacy flow detailed:', JSON.stringify(legacyFlow, null, 2));
                loadFlow(legacyFlow);
            }
            
            // Clear any previous validation errors
            document.querySelectorAll('#editModal .form-group').forEach(group => {
                group.classList.remove('error');
                const errorDiv = group.querySelector('.validation-error');
                if (errorDiv) errorDiv.style.display = 'none';
            });
            
            // Update modal title and form for edit mode
            document.querySelector('#editModal .modal-header h2').textContent = 'Edit Client Configuration';
            document.querySelector('#editModal form').setAttribute('data-mode', 'edit');
            document.querySelector('#editModal button[type="submit"]').textContent = 'Save Changes';
            
            // Site ID field is hidden since it's auto-generated
            
            // Show the modal
            document.getElementById('editModal').classList.add('active');
        }


        async function deleteClient(siteId) {
            const currentClients = window.getClients();
            const client = currentClients.find(c => c.siteId === siteId);
            const clientName = client ? client.businessName : siteId;
            
            if (confirm(`Are you sure you want to delete "${clientName}"? This cannot be undone.`)) {
                try {
                    showLoading(true);
                    
                    const response = await authenticatedFetch(`${API_BASE}/admin/clients/${siteId}`, {
                        method: 'DELETE'
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to delete client');
                    }
                    
                    showSuccess('Client deleted successfully');
                    // Reload clients list
                    await loadClients();
                } catch (error) {
                    console.error('Delete error:', error);
                    showError('Failed to delete client: ' + error.message);
                } finally {
                    showLoading(false);
                }
            }
        }

        function logout() {
            sessionStorage.removeItem('leadstick_admin_token');
            sessionStorage.removeItem('leadstick_csrf_token');
            window.location.href = './index.html';
        }

        // Utility functions
        function showLoading(show) {
            document.getElementById('loadingState').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const container = document.getElementById('statusMessage');
            
            // Clear existing content safely
            container.textContent = '';
            
            // Create error element safely
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            
            container.appendChild(errorDiv);
            setTimeout(() => container.textContent = '', 5000);
        }

        function showSuccess(message) {
            const container = document.getElementById('statusMessage');
            
            // Clear existing content safely
            container.textContent = '';
            
            // Create success element safely
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            
            container.appendChild(successDiv);
            setTimeout(() => container.textContent = '', 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }

        // Modal management functions
        function closeEditModal() {
            console.log('[closeEditModal] Closing modal');
            try {
                const modal = document.getElementById('editModal');
                if (modal) {
                    modal.classList.remove('active');
                } else {
                    console.error('[closeEditModal] Modal element not found');
                }
                window.editingClient = null;
            } catch (error) {
                console.error('[closeEditModal] Error:', error);
            }
        }

        // Color input synchronization for edit modal
        function syncEditColorInputs() {
            const colorInput = document.getElementById('editThemeColor');
            const textInput = document.getElementById('editThemeText');
            
            if (document.activeElement === colorInput) {
                textInput.value = colorInput.value;
            } else if (document.activeElement === textInput) {
                if (/^#[0-9A-Fa-f]{6}$/.test(textInput.value)) {
                    colorInput.value = textInput.value;
                }
            }
        }

        // Validation for edit form inputs
        function validateEditInput(inputId, value, type) {
            const errors = validateClientInput(inputId, value, type);
            
            if (errors.length > 0) {
                showInputError(inputId, errors[0]);
                return false;
            } else {
                clearInputError(inputId);
                return true;
            }
        }

        // Save client changes
        async function saveClientChanges(event) {
            event.preventDefault();
            
            const form = event.target;
            const formData = new FormData(form);
            const mode = form.getAttribute('data-mode') || 'edit';
            
            // Validate all fields
            let isValid = true;
            const fieldsToValidate = [
                { id: 'editBusinessName', value: formData.get('businessName'), type: 'businessName' },
                { id: 'editEmail', value: formData.get('email'), type: 'email' },
                { id: 'editAgentName', value: formData.get('agentName'), type: 'agentName' },
                { id: 'editPhone', value: formData.get('phone'), type: 'phone' },
                { id: 'welcomeMessage', value: formData.get('welcomeMessage'), type: 'message' },
                { id: 'completionMessage', value: formData.get('completionMessage'), type: 'message' },
                { id: 'phoneCtaText', value: formData.get('phoneCtaText'), type: 'message' },
                { id: 'barText', value: formData.get('barText'), type: 'barText' },
                { id: 'editThemeText', value: document.getElementById('editThemeText').value, type: 'themeColor' }
            ];
            
            // Site ID is auto-generated, no validation needed
            
            fieldsToValidate.forEach(field => {
                if (!validateEditInput(field.id, field.value, field.type)) {
                    isValid = false;
                }
            });
            
            if (!isValid) {
                showError('Please fix the validation errors before saving');
                return;
            }
            
            try {
                showLoading(true);
                
                const siteId = formData.get('siteId'); // For edit mode only
                const welcomeMessage = formData.get('welcomeMessage')?.trim();
                const completionMessage = formData.get('completionMessage')?.trim();
                const phoneCtaText = formData.get('phoneCtaText')?.trim();
                const showPhoneCta = formData.get('showPhoneCta') === 'on';
                
                const payload = {
                    business: {
                        name: sanitizeInput(formData.get('businessName')),
                        email: sanitizeInput(formData.get('email')),
                        agentName: sanitizeInput(formData.get('agentName') || ''),
                        phone: sanitizeInput(formData.get('phone') || '')
                    },
                    theme: {
                        primary: document.getElementById('editThemeText').value
                    },
                    messages: {
                        welcome: welcomeMessage || '',
                        complete: completionMessage || '',
                        phoneButton: phoneCtaText || ''
                    },
                    showPhoneCta: showPhoneCta,
                    desktopStyle: formData.get('widgetType'),
                    barText: sanitizeInput(formData.get('barText') || 'Get A Quick Quote'),
                    flow: window.currentFlow || []
                };
                
                // Site ID is auto-generated for create mode, only used for edit mode
                
                console.log(`[saveClientChanges] ${mode === 'create' ? 'Creating' : 'Updating'} client:`, siteId);
                console.log('[saveClientChanges] Current flow being saved:', window.currentFlow);
                console.log('[saveClientChanges] Flow types:', (window.currentFlow || []).map(item => ({ type: item.type, heading: item.heading, question: item.question })));
                console.log('[saveClientChanges] Form data:', Object.fromEntries(formData));
                console.log('[saveClientChanges] Payload:', JSON.stringify(payload, null, 2));
                
                // Use POST for create, PUT for edit
                const url = mode === 'create' 
                    ? `${API_BASE}/admin/clients`
                    : `${API_BASE}/admin/clients/${siteId}`;
                const method = mode === 'create' ? 'POST' : 'PUT';
                
                const response = await authenticatedFetch(url, {
                    method: method,
                    body: JSON.stringify(payload)
                });
                
                console.log('[saveClientChanges] PUT response:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok,
                    headers: Object.fromEntries(response.headers.entries())
                });
                
                const responseText = await response.text();
                console.log('[saveClientChanges] Response body:', responseText);
                
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error('[saveClientChanges] Failed to parse response as JSON:', e);
                    data = { error: 'Invalid response format' };
                }
                
                if (!response.ok) {
                    console.error('[saveClientChanges] Request failed:', data);
                    let errorMessage = data.error || `HTTP ${response.status}: Failed to update client`;
                    if (data.details && Array.isArray(data.details)) {
                        errorMessage += '\n\nDetails:\n‚Ä¢ ' + data.details.join('\n‚Ä¢ ');
                    }
                    throw new Error(errorMessage);
                }
                
                console.log(`[saveClientChanges] ${mode === 'create' ? 'Create' : 'Update'} successful:`, data);
                const defaultMessage = mode === 'create' ? 'Client created successfully' : 'Client updated successfully';
                showSuccess(data.message || defaultMessage);
                closeEditModal();
                // Reload clients list
                await loadClients();
            } catch (error) {
                console.error('Update error:', error);
                showError('Failed to update client: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Helper function to create unified flow from questions and signposts
        function createUnifiedFlow(questions = [], signposts = []) {
            const flow = [];
            
            // First, add all signposts to the flow
            signposts.forEach(signpost => {
                flow.push({
                    type: 'signpost',
                    ...signpost
                });
            });
            
            // Then add all questions
            questions.forEach(question => {
                // Ensure question has type property
                flow.push({
                    type: 'question',
                    ...question
                });
            });
            
            // Sort by order if questions have signpostId
            // Questions without signpostId come first
            flow.sort((a, b) => {
                // Signposts always come before their questions
                if (a.type === 'signpost' && b.type === 'question' && b.signpostId === a.id) {
                    return -1;
                }
                if (b.type === 'signpost' && a.type === 'question' && a.signpostId === b.id) {
                    return 1;
                }
                
                // Questions without signpost come first
                if (a.type === 'question' && b.type === 'question') {
                    if (!a.signpostId && b.signpostId) return -1;
                    if (a.signpostId && !b.signpostId) return 1;
                }
                
                return 0;
            });
            
            return flow;
        }

        // Flow Management Functions
        function loadFlow(flow = []) {
            console.log('[loadFlow] Loading flow:', flow);
            console.log('[loadFlow] Flow items:', flow.map(item => ({ type: item.type, heading: item.heading, question: item.question })));
            window.currentFlow = flow || [];
            currentFlow = window.currentFlow;
            renderFlow();
        }

        function renderFlow() {
            const questionList = document.getElementById('questionList');
            if (!questionList) return;
            
            if (currentFlow.length === 0) {
                questionList.innerHTML = `
                    <div style="text-align: center; color: #6b7280; padding: 40px;">
                        <p>No questions or signposts yet.</p>
                        <p style="font-size: 12px;">Click "Add Item" to get started.</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            let isUnderSignpost = false;
            
            currentFlow.forEach((item, index) => {
                if (item.type === 'signpost') {
                    isUnderSignpost = true;
                    html += `
                        <div class="flow-signpost" data-index="${index}">
                            <div class="flow-signpost-header">
                                <div>
                                    <h4 class="flow-signpost-title">${item.heading || 'Signpost'}</h4>
                                    <div class="flow-signpost-subtitle">${item.subheading || ''}</div>
                                </div>
                                <div class="flow-signpost-actions">
                                    <button onclick="editSignpost(${index})" title="Edit">‚úèÔ∏è</button>
                                    <button onclick="deleteFlowItem(${index})" title="Delete">üóëÔ∏è</button>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (item.type === 'question') {
                    // Check if this question should be nested under the previous signpost
                    const nestedClass = isUnderSignpost ? ' nested' : '';
                    
                    html += `
                        <div class="question-item${nestedClass}" data-index="${index}">
                            <div class="question-header">
                                <div class="question-info">
                                    <h4>${item.question || 'Question'}</h4>
                                    <div class="question-details">
                                        <span class="question-type-tag">${getQuestionTypeLabel(item.questionType)}</span>
                                        ${item.validation?.required ? '<span class="required-badge">Required</span>' : ''}
                                    </div>
                                </div>
                                <div class="question-actions">
                                    <button onclick="editQuestion(${index})" title="Edit">‚úèÔ∏è</button>
                                    <button onclick="duplicateQuestion(${index})" title="Duplicate">üìã</button>
                                    <button onclick="deleteFlowItem(${index})" title="Delete">üóëÔ∏è</button>
                                </div>
                            </div>
                            ${item.questionType === 'select' || item.questionType === 'multiselect' ? `
                                <div class="options-preview">
                                    <ul class="options-list">
                                        ${(item.options || []).map(opt => `<li>‚Ä¢ ${opt}</li>`).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            });
            
            questionList.innerHTML = html;
        }

        // Question Management Functions (legacy compatibility)
        function loadQuestions(flow = []) {
            // If flow is passed as an array, use it directly
            // If it's the old format (questions array), convert it
            if (Array.isArray(flow)) {
                // Check if this is already a flow array or old questions array
                const isFlowFormat = flow.length > 0 && flow[0].hasOwnProperty('type') && 
                                   (flow[0].type === 'signpost' || flow[0].type === 'question');
                
                if (isFlowFormat) {
                    // Extract only questions from the flow
                    const questions = flow.filter(item => item.type === 'question');
                    window.currentQuestions = questions;
                    currentQuestions = questions;
                    
                    // Also extract signposts if they exist
                    const signposts = flow.filter(item => item.type === 'signpost');
                    if (signposts.length > 0 && typeof loadSignposts === 'function') {
                        loadSignposts(signposts);
                    }
                } else {
                    // Old format - treat as questions array
                    window.currentQuestions = flow;
                    currentQuestions = flow;
                }
            } else {
                window.currentQuestions = [];
                currentQuestions = [];
            }
            renderQuestions();
        }

        function renderQuestions() {
            const questionList = document.getElementById('questionList');
            if (!questionList) return;
            
            questionList.innerHTML = '';
            
            if (currentQuestions.length === 0) {
                questionList.innerHTML = '<p style="color: #6b7280; text-align: center; padding: 20px;">No questions configured. Click "Add Question" to get started.</p>';
                return;
            }
            
            currentQuestions.forEach((question, index) => {
                const questionItem = createQuestionItem(question, index);
                questionList.appendChild(questionItem);
            });
        }

        function createQuestionItem(question, index) {
            const item = document.createElement('div');
            item.className = 'question-item';
            item.draggable = true;
            item.setAttribute('data-index', index);
            
            const questionTypeLabels = {
                text: 'üìù Text Input',
                select: 'üìã Single Choice',
                multiselect: '‚òëÔ∏è Multiple Choice',
                firstName: 'üë§ First Name',
                lastName: 'üë§ Last Name',
                email: 'üìß Email Address',
                phone: 'üìû Phone Number'
            };
            
            item.innerHTML = `
                <div class="question-header">
                    <div class="question-info">
                        <h4>${escapeHtml(question.question || 'Untitled Question')}</h4>
                        <span class="question-type">${questionTypeLabels[question.type] || question.type}</span>
                    </div>
                    <div class="question-actions">
                        <button type="button" onclick="editQuestion(${index})">‚úèÔ∏è Edit</button>
                        <button type="button" onclick="deleteQuestion(${index})">üóëÔ∏è Delete</button>
                        <span class="drag-handle">‚ãÆ‚ãÆ</span>
                    </div>
                </div>
                <div class="question-preview">
                    ${getQuestionPreview(question)}
                </div>
            `;
            
            // Add drag and drop event listeners
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('drop', handleDrop);
            item.addEventListener('dragend', handleDragEnd);
            
            return item;
        }

        function getQuestionPreview(question) {
            let preview = escapeHtml(question.question || 'Untitled Question');
            
            if (question.placeholder) {
                preview += `<br><small style="color: #9ca3af;">Placeholder: ${escapeHtml(question.placeholder)}</small>`;
            }
            
            if (question.options && question.options.length > 0) {
                preview += '<ul class="options-list">';
                question.options.slice(0, 3).forEach(option => {
                    preview += `<li>${escapeHtml(option)}</li>`;
                });
                if (question.options.length > 3) {
                    preview += `<li>... and ${question.options.length - 3} more</li>`;
                }
                preview += '</ul>';
            }
            
            return preview;
        }

        function toggleQuestionDropdown() {
            const dropdown = document.getElementById('questionDropdown');
            dropdown.classList.toggle('show');
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function closeDropdown(e) {
                if (!e.target.closest('.add-question-dropdown')) {
                    dropdown.classList.remove('show');
                    document.removeEventListener('click', closeDropdown);
                }
            });
        }

        function addQuestion(type) {
            // Close dropdown
            document.getElementById('questionDropdown').classList.remove('show');
            
            // Open question editor
            openQuestionEditor(type);
        }

        function editQuestion(index) {
            const item = currentFlow[index];
            if (!item || item.type !== 'question') return;
            
            window.editingItemIndex = index;
            openQuestionEditor(item.questionType, item);
        }

        function duplicateQuestion(index) {
            const item = currentFlow[index];
            if (!item || item.type !== 'question') return;
            
            // Create a duplicate with a new ID
            const duplicate = {
                ...item,
                id: `question_${Date.now()}`,
                question: item.question + ' (Copy)'
            };
            
            // Insert after the original question
            currentFlow.splice(index + 1, 0, duplicate);
            window.currentFlow = currentFlow;
            renderFlow();
        }

        function deleteQuestion(index) {
            const question = currentQuestions[index];
            if (!question) return;
            
            if (confirm(`Are you sure you want to delete the question "${question.question}"?`)) {
                currentQuestions.splice(index, 1);
                window.currentQuestions = currentQuestions;
                renderQuestions();
            }
        }

        function openQuestionEditor(type, existingQuestion = null) {
            const modal = document.getElementById('questionEditorModal');
            const title = document.getElementById('questionEditorTitle');
            const form = document.getElementById('questionEditorForm');
            
            // Reset form
            form.reset();
            
            // Set title
            title.textContent = existingQuestion ? 'Edit Question' : 'Add Question';
            
            // Set default type
            document.getElementById('questionType').value = existingQuestion ? existingQuestion.questionType : type;
            
            // Note: Signpost assignment is now handled through the flow structure
            
            // Set default question text for contact fields
            if (!existingQuestion) {
                const defaultQuestions = {
                    firstName: "What's your first name?",
                    lastName: "What's your last name?", 
                    email: "What's your email address?",
                    phone: "What's your phone number?"
                };
                
                if (defaultQuestions[type]) {
                    document.getElementById('questionText').value = defaultQuestions[type];
                }
            }
            
            // Populate existing question data
            if (existingQuestion) {
                document.getElementById('questionText').value = existingQuestion.question || '';
                document.getElementById('questionPlaceholder').value = existingQuestion.placeholder || '';
                document.getElementById('questionRequired').checked = existingQuestion.validation?.required !== false;
                // Signpost assignment is now handled through flow structure
                
                if (existingQuestion.validation?.minLength) {
                    document.getElementById('minLength').value = existingQuestion.validation.minLength;
                }
                
                if (existingQuestion.validation?.minSelection) {
                    document.getElementById('minSelection').value = existingQuestion.validation.minSelection;
                }
                
                // Load options for select/multiselect
                if (existingQuestion.options) {
                    const optionsList = document.getElementById('optionsList');
                    optionsList.innerHTML = '';
                    existingQuestion.options.forEach(option => {
                        addOptionToList(option);
                    });
                }
            }
            
            // Update UI based on question type
            updateQuestionTypeOptions();
            
            // Show modal
            modal.classList.add('active');
        }

        function closeQuestionEditor() {
            document.getElementById('questionEditorModal').classList.remove('active');
            window.editingQuestionIndex = -1;
            editingQuestionIndex = -1;
        }

        function updateQuestionTypeOptions() {
            const type = document.getElementById('questionType').value;
            const placeholderGroup = document.getElementById('placeholderGroup');
            const optionsGroup = document.getElementById('optionsGroup');
            const minLengthGroup = document.getElementById('minLengthGroup');
            const minSelectionGroup = document.getElementById('minSelectionGroup');
            
            // Show/hide options based on question type
            if (type === 'select' || type === 'multiselect') {
                optionsGroup.style.display = 'block';
                placeholderGroup.style.display = 'block';
                
                // Ensure at least one option exists
                const optionsList = document.getElementById('optionsList');
                if (optionsList.children.length === 0) {
                    addOption();
                    addOption();
                }
            } else {
                optionsGroup.style.display = 'none';
            }
            
            // Contact field types don't need placeholders (they have preset labels)
            const contactTypes = ['firstName', 'lastName', 'email', 'phone'];
            if (contactTypes.includes(type)) {
                placeholderGroup.style.display = 'none';
            } else {
                placeholderGroup.style.display = 'block';
            }
            
            // Show validation options
            minLengthGroup.style.display = type === 'text' ? 'block' : 'none';
            minSelectionGroup.style.display = type === 'multiselect' ? 'block' : 'none';
        }

        function addOption() {
            const optionsList = document.getElementById('optionsList');
            addOptionToList('');
        }

        function addOptionToList(value = '') {
            const optionsList = document.getElementById('optionsList');
            const optionDiv = document.createElement('div');
            optionDiv.className = 'option-item';
            
            optionDiv.innerHTML = `
                <input type="text" value="${escapeHtml(value)}" placeholder="Option text" maxlength="100" required>
                <button type="button" onclick="removeOption(this)">‚úï</button>
            `;
            
            optionsList.appendChild(optionDiv);
        }

        function removeOption(button) {
            const optionItem = button.closest('.option-item');
            const optionsList = document.getElementById('optionsList');
            
            // Don't allow removing all options
            if (optionsList.children.length > 1) {
                optionItem.remove();
            } else {
                alert('At least one option is required for choice questions.');
            }
        }

        function saveQuestion(event) {
            event.preventDefault();
            
            const form = event.target;
            const formData = new FormData(form);
            
            const question = {
                id: window.editingItemIndex >= 0 ? currentFlow[window.editingItemIndex].id : generateQuestionId(),
                type: 'question',
                questionType: formData.get('questionType'),
                question: formData.get('questionText').trim(),
                validation: {
                    required: formData.get('questionRequired') === 'on'
                }
            };
            
            // Add placeholder if provided
            const placeholder = formData.get('questionPlaceholder')?.trim();
            if (placeholder) {
                question.placeholder = placeholder;
            }
            
            // Note: Signpost assignment is now handled through flow structure
            
            // Add type-specific fields
            if (question.questionType === 'text' && formData.get('minLength')) {
                question.validation.minLength = parseInt(formData.get('minLength'));
            }
            
            if (question.questionType === 'multiselect' && formData.get('minSelection')) {
                question.validation.minSelection = parseInt(formData.get('minSelection'));
            }
            
            // Add options for select/multiselect
            if (question.questionType === 'select' || question.questionType === 'multiselect') {
                const optionInputs = document.querySelectorAll('#optionsList input');
                question.options = Array.from(optionInputs)
                    .map(input => input.value.trim())
                    .filter(value => value.length > 0);
                
                if (question.options.length === 0) {
                    alert('Please add at least one option for choice questions.');
                    return;
                }
            }
            
            // Add or update question
            if (window.editingItemIndex >= 0) {
                currentFlow[window.editingItemIndex] = question;
            } else {
                currentFlow.push(question);
            }
            
            window.currentFlow = currentFlow;
            renderFlow();
            closeQuestionEditor();
        }

        function generateQuestionId() {
            return 'q_' + Math.random().toString(36).substr(2, 9);
        }

        // Drag and drop functions
        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            
            if (draggedElement && draggedElement !== e.target) {
                const draggedIndex = parseInt(draggedElement.getAttribute('data-index'));
                const targetIndex = parseInt(e.target.closest('.question-item')?.getAttribute('data-index'));
                
                if (draggedIndex !== undefined && targetIndex !== undefined && draggedIndex !== targetIndex) {
                    // Reorder questions array
                    const draggedQuestion = currentQuestions[draggedIndex];
                    currentQuestions.splice(draggedIndex, 1);
                    currentQuestions.splice(targetIndex, 0, draggedQuestion);
                    
                    window.currentQuestions = currentQuestions;
                    renderQuestions();
                }
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedElement = null;
        }

        // Copy installation code function
        async function copyInstallationCode(siteId) {
            try {
                const installationCode = `<!-- LeadStick Widget -->
<script>
window.leadstickConfig = {
    siteId: '${siteId}',
    apiUrl: '${API_BASE}'
};
<\/script>
<script src="https://pub-2cf19529958742fea36d2ac68c558716.r2.dev/widget.js" async><\/script>
<!-- End LeadStick Widget -->`;

                // Copy to clipboard
                await navigator.clipboard.writeText(installationCode);
                
                // Show success message
                showSuccess(`Installation code copied to clipboard for ${siteId}`);
                
                console.log('[copyInstallationCode] Code copied for client:', siteId);
            } catch (error) {
                console.error('[copyInstallationCode] Error:', error);
                
                // Fallback for browsers that don't support clipboard API
                const installationCode = `<!-- LeadStick Widget -->
<script>
window.leadstickConfig = {
    siteId: '${siteId}',
    apiUrl: '${API_BASE}'
};
<\/script>
<script src="https://pub-2cf19529958742fea36d2ac68c558716.r2.dev/widget.js" async><\/script>
<!-- End LeadStick Widget -->`;
                
                const textArea = document.createElement('textarea');
                textArea.value = installationCode;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                showSuccess(`Installation code copied to clipboard for ${siteId}`);
            }
        }

        // Placeholder functions for other features
        function setupColorInputSync() {
            // Implemented in syncEditColorInputs function
        }

        function setupDragAndDrop() {
            // Will implement when adding full question builder functionality
        }
        
        // Export functions to global scope for onclick handlers
        window.authenticatedFetch = authenticatedFetch;
        window.editClient = editClient;
        window.deleteClient = deleteClient;
        window.closeEditModal = closeEditModal;
        window.syncEditColorInputs = syncEditColorInputs;
        window.validateEditInput = validateEditInput;
        window.saveClientChanges = saveClientChanges;
        window.openNewClientModal = openNewClientModal;
        window.copyInstallationCode = copyInstallationCode;
        window.logout = logout;
        window.filterClients = filterClients;
        window.validateSearchInput = validateSearchInput;
        window.showError = showError;
        window.showSuccess = showSuccess;
        window.showLoading = showLoading;
        window.loadClients = loadClients;
        window.sanitizeInput = sanitizeInput;
        window.validateClientInput = validateClientInput;
        window.showInputError = showInputError;
        window.clearInputError = clearInputError;
        window.loadFlow = loadFlow;
        window.renderFlow = renderFlow;
        window.loadQuestions = loadQuestions;
        window.toggleQuestionDropdown = toggleQuestionDropdown;
        window.addQuestion = addQuestion;
        window.editQuestion = editQuestion;
        window.duplicateQuestion = duplicateQuestion;
        window.deleteQuestion = deleteQuestion;
        window.deleteFlowItem = deleteFlowItem;
        window.closeQuestionEditor = closeQuestionEditor;
        window.updateQuestionTypeOptions = updateQuestionTypeOptions;
        window.addOption = addOption;
        window.removeOption = removeOption;
        window.saveQuestion = saveQuestion;
        window.addSignpost = addSignpost;
        window.openSignpostEditor = openSignpostEditor;
        window.closeSignpostEditor = closeSignpostEditor;
        window.saveSignpost = saveSignpost;
        window.editSignpost = editSignpost;
        window.getQuestionTypeLabel = getQuestionTypeLabel;

        // SIGNPOST MANAGEMENT FUNCTIONS
        function loadSignposts(signposts = []) {
            window.currentSignposts = signposts;
            currentSignposts = signposts;
            renderSignposts();
        }

        function renderSignposts() {
            const signpostList = document.getElementById('signpostList');
            if (!signpostList) return;
            
            if (currentSignposts.length === 0) {
                signpostList.innerHTML = `
                    <div style="text-align: center; color: #6b7280; padding: 40px;">
                        <p>No signposts configured yet.</p>
                        <p style="font-size: 12px;">Add signposts to organize your questions into groups.</p>
                    </div>
                `;
                return;
            }
            
            signpostList.innerHTML = currentSignposts.map((signpost, index) => `
                <div class="signpost-item" data-index="${index}">
                    <div class="signpost-header-content">
                        <div class="signpost-info-content">
                            <h4>${signpost.title}</h4>
                            <p>${signpost.description}</p>
                        </div>
                        <div class="signpost-actions">
                            <button onclick="editSignpost(${index})" title="Edit">‚úèÔ∏è</button>
                            <button onclick="deleteSignpost(${index})" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="signpost-questions">
                        <h5>Questions in this signpost:</h5>
                        <div class="signpost-question-list">
                            ${getQuestionsForSignpost(signpost.id).map(q => `
                                <span class="signpost-question-tag">${q.question}</span>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function getQuestionsForSignpost(signpostId) {
            return currentQuestions.filter(q => q.signpostId === signpostId);
        }

        function populateSignpostDropdown() {
            const select = document.getElementById('questionSignpost');
            if (!select) return;
            
            // Clear existing options except the first one
            select.innerHTML = '<option value="">No signpost (ungrouped)</option>';
            
            // Add signpost options
            currentSignposts.forEach(signpost => {
                const option = document.createElement('option');
                option.value = signpost.id;
                option.textContent = signpost.title;
                select.appendChild(option);
            });
        }

        function addSignpost() {
            // Close dropdown
            document.getElementById('questionDropdown').classList.remove('show');
            // Open signpost editor
            openSignpostEditor();
        }

        function openSignpostEditor(existingSignpost = null, index = -1) {
            const modal = document.getElementById('signpostEditorModal');
            const title = document.getElementById('signpostEditorTitle');
            const form = document.getElementById('signpostEditorForm');
            
            // Reset form
            form.reset();
            
            // Set title and populate data
            if (existingSignpost) {
                title.textContent = 'Edit Signpost';
                document.getElementById('signpostHeading').value = existingSignpost.heading || '';
                document.getElementById('signpostSubheading').value = existingSignpost.subheading || '';
                window.editingItemIndex = index;
            } else {
                title.textContent = 'Add Signpost';
                window.editingItemIndex = -1;
            }
            
            // Show modal
            modal.classList.add('active');
        }

        function closeSignpostEditor() {
            document.getElementById('signpostEditorModal').classList.remove('active');
            window.editingItemIndex = -1;
        }

        function saveSignpost(event) {
            event.preventDefault();
            
            const form = event.target;
            const formData = new FormData(form);
            
            const signpost = {
                id: window.editingItemIndex >= 0 ? currentFlow[window.editingItemIndex].id : `signpost_${Date.now()}`,
                type: 'signpost',
                heading: formData.get('signpostHeading').trim(),
                subheading: formData.get('signpostSubheading').trim()
            };
            
            // Add or update signpost
            if (window.editingItemIndex >= 0) {
                currentFlow[window.editingItemIndex] = signpost;
            } else {
                currentFlow.push(signpost);
            }
            
            window.currentFlow = currentFlow;
            renderFlow();
            closeSignpostEditor();
        }

        function editSignpost(index) {
            const item = currentFlow[index];
            if (!item || item.type !== 'signpost') return;
            openSignpostEditor(item, index);
        }

        function deleteFlowItem(index) {
            const item = currentFlow[index];
            if (!item) return;
            
            const itemType = item.type === 'signpost' ? 'signpost' : 'question';
            const itemName = item.type === 'signpost' ? item.heading : item.question;
            
            if (confirm(`Are you sure you want to delete this ${itemType}? "${itemName}"`)) {
                currentFlow.splice(index, 1);
                window.currentFlow = currentFlow;
                renderFlow();
            }
        }

        function getQuestionTypeLabel(type) {
            const types = {
                'text': 'üìù Text',
                'select': 'üìã Choice',
                'multiselect': '‚òëÔ∏è Multi-Choice',
                'firstName': 'üë§ First Name',
                'lastName': 'üë§ Last Name',
                'email': 'üìß Email',
                'phone': 'üìû Phone'
            };
            return types[type] || type;
        }

        function editSignpost(index) {
            const signpost = currentSignposts[index];
            if (!signpost) return;
            
            const newTitle = prompt('Signpost Title:', signpost.title);
            if (newTitle === null) return;
            
            const newDescription = prompt('Signpost Description:', signpost.description);
            if (newDescription === null) return;
            
            signpost.title = newTitle;
            signpost.description = newDescription;
            
            currentSignposts[index] = signpost;
            window.currentSignposts = currentSignposts;
            renderSignposts();
        }

        function deleteSignpost(index) {
            const signpost = currentSignposts[index];
            if (!signpost) return;
            
            const questionsInSignpost = getQuestionsForSignpost(signpost.id);
            let confirmMessage = `Are you sure you want to delete "${signpost.title}"?`;
            
            if (questionsInSignpost.length > 0) {
                confirmMessage += `\n\nThis will also remove the signpost assignment from ${questionsInSignpost.length} question(s).`;
            }
            
            if (confirm(confirmMessage)) {
                // Remove signpost assignment from questions
                currentQuestions.forEach(q => {
                    if (q.signpostId === signpost.id) {
                        delete q.signpostId;
                    }
                });
                
                currentSignposts.splice(index, 1);
                window.currentSignposts = currentSignposts;
                window.currentQuestions = currentQuestions;
                renderSignposts();
                renderQuestions();
            }
        }

        // Export signpost functions to global scope
        window.loadSignposts = loadSignposts;
        window.renderSignposts = renderSignposts;
        window.addSignpost = addSignpost;
        window.editSignpost = editSignpost;
        window.deleteSignpost = deleteSignpost;
        window.getQuestionsForSignpost = getQuestionsForSignpost;
        window.populateSignpostDropdown = populateSignpostDropdown;
        
        // Add event listeners for widget type changes
        document.getElementById('editBubble').addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('barTextGroup').style.display = 'none';
            }
        });
        
        document.getElementById('editFloatingBar').addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('barTextGroup').style.display = 'block';
            }
        });
        
        } // End of initializeAppComponents function
    </script>
</body>
</html>